> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/57708956)

**编程的本质**
---------

当写过许许多多程序后，接触了那么多编程模式、设计模式、框架、语言、算法、数据结构以后，就会发现编程的本质万变不离其宗就是，操纵一坨数据。当然操纵的方式有许多，存储的方式也五花八门，但是本质不变，就是访问数据（读取以及改变）。

下面谈一谈我对两种编程方式的理解，就是面向对象编程，以及函数式编程。我用 JavaScript 这种神奇的语言来解释，因为 JavaScript 既可以面向对象编程，也可以函数式编程。

数据存放方式
------

1、对于 OO（面向对象，下同），数据存放在对象的属性（成员变量）里面，以及静态成员（全局变量）

2、对于函数式，数据存放在闭包（各级作用域）里面，作用域包括全局作用域。

数据访问方式
------

数据存放方式决定了访问的方式。

1、对于 OO 来说，访问数据（全局变量除外）需要先获取对象的引用，然后再进行操作（直接访问——公共属性，或者调用成员函数 / 方法访问——私有属性）

2、对于函数式，访问数据是直接访问（通过函数入参或者作用域链查找）

下面上一段代码
-------

```
//OO
class Foo {
  constructor(){
    this.bar = 0
  }
}
let foo = new Foo()
foo.bar ++

//函数式

let bar = 0
function foo(){
    bar ++
}
foo()


```

这是随便写了一些没有用代码，只是为了展示两种风格的编程方式。

从中我们可以看出一些东西，OO 是通过持有，以及传递对象的方式去让别的对象来操作数据，而对象也会是其他对象的成员，层层嵌套。当你想要访问某一个数据的时候，就需要顺着对象的引用链条去找，一步步去操作。

函数式传递的则是函数，调用函数即操作数据，传递函数的时候其实隐含着传递了函数创建的时候所附带的作用域，这个在表面上看不出来，在底层是有的。

**OO 所谓的对象，本质上就是函数式中的作用域。**

为了理解这句话，我们来看**高阶函数**的本质

```
function foo(x){
  let bar = x
  return function(){
     return bar
  }
}
let Bar = foo(1)
console.log(Bar())//1

```

当调用 foo(1) 的时候返回一个函数，这个函数可以访问 foo 函数内部的 bar 变量，这就是高阶函数。如果翻译成 OO 思想大家就知道怎么回事了。

```
class Foo{
  constructor(x){
    this.bar = x
  }
  Bar(){
    return this.bar
  }
}
let foo = new Foo(1)
console.log(foo.Bar())

```

看上去是不是差不多。其实在 C# 中对 lambda 表达式的编译就是这个原理。会内部创建一些类。

当然高阶函数的写法肯定不会这么啰嗦，会写的比较优雅。(**这就是本质区别**）

```
let foo = bar=>()=>bar
let Bar = foo(1)
console.log(Bar())//1

```

所以 OO 编程，是面向作用域编程，而函数式编程，是面向功能编程。

函数式编程有一个巨大的优势，就是作用域链，也就是说函数可以访问的变量范围要远远大于 OO，灵活性就成几何级数上升。换句话也可以说 OO 的约束性更强。

Javascript 超越了函数式以及 OO
----------------------

在 JS 中约束进一步被打破，JS 中可以修改函数的 “作用域”，类的成员方法可以以另一个对象为作用域。JS 还可以更换父类，这在其他 OO 语言是难以想象和不可理喻的。

所以 Javascript 可以用最简短代码来代替 OO 许多代码，究其本质，就是 OO 需要不断的传递、持有不同的作用域——对象。而 Javascript 只需要处在作用域链内，即可轻易访问到所需要的数据。




早期的高级编程语言（1950s）多是面向过程的，所谓过程就是对逻辑执行的实现，表明程序要先做什么后做什么，就像是对流程图的翻译，简单直接，适合小型程序。随着软件复杂度的提升，出现了两次软件危机，催生了面向对象的出现。第一次软件危机（1960s、1970s）即软件质量低下、项目无法如期完成、项目严重超支等，也导致了一些重大事故，如1963年美国水手一号火箭发射失败。应对方案是采用结构化设计，即取消goto（采用顺序、选择、循环这三种基本控制来构造程序），采取“自顶向下、逐步细化、模块化”的指导思想来构建程序，实现了对复杂逻辑的分治。第二次软件危机（1980s）是软件的生产力远远跟不上硬件和业务的发展，主要体现在软件的“扩展”变得非常复杂。为了应对这次危机，新兴的编程语言采用面向对象，进一步将数据结构和算法内聚，进行封装，保证其可重用与解耦合，其中常见技巧便成为了大家常说的设计模式。至此，高级编程语言发展基本稳定。而函数式编程在早期编程语言中就有，比如lisp，虽然面向对象语言大都后面支持了函数式编程，但其像是一种语法糖，相比于面向过程到面向对象，并不是一个巨大的飞跃。当面向对象成为主流后，如果需要传递一个函数，那就需要先将其封装为对象进行传递，与面向过程的c仅传递函数指针相比，明显此时变得更复杂了，所以催生出了函数式编程的语法糖，作为对面向对象编程的补充，将函数看做一等公民，二不再需要其一定附着与某个对象，方便对函数的使用。

函数式编程把数据与操作逻辑区分开, 然后各种组合;

面向对象把数据与操作逻辑合并到一块, 形成一个封装, 再各种应用;

分开使用显然比合在一起使用要灵活, 真正需要封装的时候再去谈面向对象...

偏偏人们已经把面向对象当成了组织代码的方式了, 不需要封装的时候也非要用面向对象...函数式编程对开发者要求更高一些，需要对程序的理解更深入。面向对象则更浅显，所以为了让公司里面良莠不齐的开发人员统一协作，就逐渐采用了以面向对象为主的开发模式。
闭包和对象都是把数据从stack复制到heap里去
程序本质就是操作数据，oop和fp都把数据封装到属性中，oop通过对象封装和操作属性。fp通过函数来操作属性。