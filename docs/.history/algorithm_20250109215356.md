# algorithm  
做题核心思想：
* 先套已有框架，套进去之后用几个循环？怎么递归？思考每一轮循环都要处理什么，每个循环当成一个单位的意识
* 参数/返回值设置及其初始化
* 边界条件的判断
遇到有思路写出来一直报错的情况可以给gpt看
    


## 图遍历dfs，bfs  
所谓搜索也就是记录当前状态和寻找下一状态。  
dfs通常递归实现，函数参数定义状态，递归跳转状态，找到解就over。先探到底再向上回溯，中间可能会产生大量无效探索，需要剪枝策略。  
bfs通常队列实现，队列中每个元素对应一个状态，转移状态就操作队列出队入队，搜索顺序是逐层的。  
另外这两种方法本质上其实都是穷举，算法时间复杂度和具体使用的数据结构有关。   
![](https://cdn.jsdelivr.net/gh/EuphratesG/myPic@main/202401241457941.png)
## 单源最短路径  
### 迪杰斯特拉
1. 设置dis数组，dis[i]表示起点start到i的距离。
2. 从点集V中**弹出一个dis值最小**且**未以该点为起点进行松弛操作的**点。
3. 从该点松弛与其领接的各个点更新dis数组，返回S2，循环进行。  

```c++
//O((V+E)logV) 若不用优先队列则是O(VE)
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;//点的集合范围
const int maxm=2e5+5;//边的集合范围
​
struct edge{
    int to,cost;
};
​
struct node{ //重载<方便优先队列
    int num,dis;
    bool operator < (const node &x)const{//tm必须重载<是因为priority_queue第三个参数是less<T>，相当于重载<
        return x.dis < dis;
    }//当比较器返回true时第一个参数在前面第二个参数在后面（队列从队头pop所以这样优先级高的大）
};
​
vector<edge> e[maxm];
int dis[maxn];
bool vis[maxn]; // 布尔型vis数组
int n,m,s,cnt=0;
priority_queue <node> q;
​
void add_edge(int u,int v,int w) // 存边
{
    e[u].push_back((edge){v,w}); //匿名类省去起名
}
​
void dijkstra()
{
    dis[s]=0;
    q.push((node){s,0});
    while (!q.empty())
    {
        node tmp=q.top();
        q.pop();
        int x=tmp.num;
        if (vis[x]) continue;
        vis[x]=1;
        for (edge k:e[x]) // 遍历边信息，请注意洛谷请选用c++11，否则编译错误
        {
            if (dis[x] + k.cost < dis[k.to])
            {
                dis[k.to]=dis[x]+k.cost;
                if (!vis[k.to]) q.push((node){k.to,dis[k.to]});
            }
        }
    }
}
​
int main()
{
    cin>>n>>m>>s;
    int i;
    for (i=1;i<=n;i++) dis[i]=0x7fffffff;
    for (i=0;i<m;i++)
    {
        int u,v,w;
        cin>>u>>v>>w;
        add_edge(u,v,w);
    }
    dijkstra();
    for (i=1;i<=n;i++) cout<<dis[i]<<" ";
    return 0;
}
```
由此引出自定义比较函数（通常用于结构体）的方法：  
1. sort()
```c++
//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
//首先我们要写一个bool类型的方法，用来返回参数的比较结果
//当比较器返回true时，第一个参数放在前面，第二个参数放在后面，即位置不变
//当比较器返回false时，为两元素交换位置
//这里要注意对参数相等时的处理,因为可能会在两者相等的时候交换位置，在一些特定的环境下会导致题解出错
//比较器最好写成static函数
//比较器的值可以使用引用类型,节省空间开销
static bool cmp1(int &lhs,int &rhs)//升序
{
	return lhs<rhs;
}
static bool cmp2(int &lhs,int &rhs)//降序
{
	return lhs>rhs;
}

bool comp1(Test A,Test B){
     if(A.num==B.num) return A.str<B.str; // 字符串str字典序小的在前
     return A.num > B.num ;               // 出现次数高的元素在前
}

sort(arr,arr+10,cmp1);//升序
sort(arr,arr+10,cmp1);//降序
```
2. 优先队列
```c++
//优先队列自定义比较器处理方法1，处理方法2是戴上镣铐重载<
bool cmp(vector<int>&a,vector<int>&b){
	return a[0]>b[0];
}
priority_queue<vector<int>,vector<vector<int>>,decltype(&cmp)> pq(cmp); //注意队列pq还要传入cmp
```






# 代码随想录

## 常用stl
- vector <>string 就是二维数组的使用方法常见于棋盘问题
- 常用库函数
```c++
字符串reverse on
swap o1
isdigit()
```
- vector、stack、queue（换成push和pop以及front和top，其他完全一致）
```c++
//只列需要记住的点
std::vector<int> v(10, 5);  // 创建包含10个元素，每个元素的值为5
v.pop_back();  // 移除最后一个元素
v.insert(v.begin() + 1, 5);  // 在第二个位置插入元素5
v.erase(v.begin() + 1);  // 删除第二个元素
v.erase(v.begin(), v.begin() + 2);  // 删除前两个元素
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = {4, 5, 6};
v1.swap(v2);  // 交换v1和v2的内容
v.front();
v.back();
```

- unordered_set<> 
```c++
//和数组的区别很明显没法访问下标也不连续，优点是可以无限个元素
//构造函数跨容器构造，当然还有默认构造和拷贝构造、初始化列表、制定大小构造
vector<int>& nums1
unordered_set<int> nums_set(nums1.begin(), nums1.end());

std::unordered_set<int> set = {10, 20, 30};
std::unordered_set<int> set(10);  // 初始化时有 10 个桶

//插入
std::unordered_set<int> set;
set.insert(10);
set.insert(20);
//查找
auto it = set.find(10);
if (it != set.end()) {
    std::cout << "Found: " << *it << std::endl;
}
//其他
empty() size() erase()

```

- std::unordered_map <int,int> map;

```c++
//和set的操作区别在于：
//插入
map.insert({1, 100});
map.insert(pair<int, int>(nums[i], i));
//访问
std::unordered_map<int, int> map = {{1, 100}, {2, 200}, {3, 300}};
map[1] = 100;  // 插入键1对应的值100
int value = map[1];  // 获取键1的值

//这也是一种写法，其实直接[]key值访问也行，返回这里返回的是vector
// 遍历当前元素，并在map中寻找是否有匹配的key
auto iter = map.find(target - nums[i]); 
if(iter != map.end()) {
    return {iter->second, i};
}
```
## 常用代码模板

二叉树前序（递归/迭代）、中序（递归/cur迭代）、后序（递归/前序逆转）、层序遍历（while for）  
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }

## 细节错误

- queue只有push没有pushback
- treenode传参的时候如果需要改变root树就加一层指针（例如链表init的时候），只需要遍历就不用
- que.front()在队列为空的时候会有野指针，不要这样用，直接用que.empty()
- 递归问题的源数据源千万不要修改，例如排列问题要剪枝而不要修改数据源
- string有+=没有-=，但是有pop_back
- 函数要有一个默认的return，return不能全在if语句里
- 可以明白vector是可以不初始化的，层序遍历初始化反而不知道怎么初始化
- stack.top()不能直接stack.top()->val，而是必须cur = stack.top() cur->val

//int和node类型啊  
//判断空树空指针啊  
//if(root == nullptr) return result 返回result就是空vec，不能返回nullptr，因为返回值是vec啊  
//api遗忘啊
//空指针和特殊情况判断！边界条件啊sai  
//动态规划fn是n+1个元素常常  


普通数组的数组名在大多数上下文中被视为指针，通常无需 &。
std::vector 是一个对象，nums 表示对象本身，而 &nums 表示对象的地址，必须显式使用 & 来传递指针。  

初始化方法
        vector<vector<int>> dp(n, vector<int>(2, 0));


## 双指针 数组、链表、字符串题目
- lc27 lc151 数组中删除指定数值的元素 慢指针原地构建新数组，快指针遍历。本题的思想还能用来删除一个字符串中的所有空格（后面需要再自己加）  
- lc977对快排的优化 头尾指针都用于遍历。
  - 双指针法怎么来的呢？首先观察数组性质空间上不能用原数组（因为构建指针不能退格），所以要引入空间复杂度on。再有，构建指针从大还是小从哪开始呢？从小到大显然不行因为平方后小数在原数组的中间，再考虑到原数组平方后是u形，想到前后反向双指针比大小。时间复杂度on
- lc209 滑动窗口优化暴力。要考虑只有一个for那么指针要代表起始位置还是结束位置？另外循环内部该if就if就行，if冗余优化成while条件是后面的事  
- lc19删除链表倒数第n个节点 **二元对立补集思想，本质是双指针的相对距离不变为n**
- 链表相交 算一个差让两个指针对齐
- lc142环形链表 **双指针找环**快指针走2慢指针走1，如果有环的话慢指针进环的那一刻两指针的相对距离就固定了一定能相遇。ok判断有环之后环入口怎么找？通过数学推导
- lc1两数之和 lc15三数之和 lc18四数之和 补集思想的哈希能解决这种在集合中存不存在的问题。 **双指针也能解决，先定一个值然后剩下两个指针分别处理大了小了。但是问题是一定要排序天然有快排的时间复杂度，而且排序后下标也乱了。**
- 字符串替换数字为number 使用空间复杂度很简单，但**原地构建的话要先申请足够的长度然后双指针同时从后向前遍历**




## 数组、字符串
### 字符串就是字符数组，使用string的reverse（n）、swap（1）等，还有右旋字符串这种题，还有kmp
- kmp主要分为构建next数组（前缀表，三种实现形式）和实际匹配。匹配不上时看next数组前一个值，原串的后缀等于模式串的前缀，因此可以跳过这个重叠部分。另外实现中注意while(j >= 0 && s[i] != t[j + 1])代表不匹配，因为退回去的时候j还是代表后缀末尾的后一个元素，i代表前缀末尾的后一个元素，还是可能不匹配的。
### 主要是三要素、双指针、模拟 数组是可以排序的！
* 区间定义（循环不变量）决定了left、right取不取等号（left==right的时候有没有意义）、middle-1（下轮循环不要包含本轮循环的点）等  
* **三要素：数据结构建模（数组和链表）和边界判断/终止条件（怎么想？就想极端情况，还有特殊元素奇偶数等的处理）、实际逻辑（每个循环的清晰逻辑）、参数设置/初始化**
  
* 27题删除指定值的所有元素，**vector.erase实际上是O（n）的复杂度**，因为有前移操作，因此暴力是n2的复杂度。双指针法快指针先走赋值给慢指针，把原数组覆盖不引入空间复杂度。太不熟了！同向逆向双指针都可以考虑，**而且不用真的定义指针，反而真定义指针才是错了，因为vector只能用头部指针操作，数组的指针直接用int下标表示就行**。  

* 58题**区间和，空间换时间，先计算好再查表，n*m优化到n+m**
* 44题开发商购买土地，二维前缀和，当然也可以对暴力进行优化。这里的建模方法连暴力都没想起来，要重视一下。 vector<vector<int>> vec(n, vector<int>(m, 0)) ;
* 59题螺旋矩阵 很好的大模拟，要么代码随想录的以圈为边界，要么就以达到最大数为边界手动操作缩圈


指针分配内存，有地址（编译器和程序员看来），属于一个类型变量，支持取地址与解引用操作。
引用分配内存，有地址（编译器看来），相当于一个变量别名，不支持取地址与解引用操作（即不可获取其本身地址），声明即必须初始化，不可变更引用对象，本质上是“pointer const”，和指针的本质一样，相当于省略了指针*a取值的过程。  


## 链表
### 主要是链表操作、双指针、数学思想
链表删除节点的时候，要找前一个节点来修改指针域去跳过待删除节点，如果没有头结点的版本要删除第一个节点还要不同的操作（把第二个节点赋给head）。因此引入头结点来对头部的操作统一。  
**一般是用指针来操作链表**，虽然有些时候节点操作也行但不好归类。    
```c++
ListNode* dummyhead= new ListNode(0,head);
ListNode * cur = dummyhead;
```
链表的一些基本操作：获取第n个节点的数值、头插尾插、删除第n个节点、在第n个节点前面插入  
链表翻转，双指针+临时指针比较易得的思路。（另外这题也可以用递归来写，不过实际上和循环本质完全一样而且晦涩难懂，没有体现递归分治的特点）  
lc19删除链表倒数第n个节点，这里涉及双指针的二元对立补集思想。[算法思想](./算法思想.md)

最基本的链表节点定义：  

```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

力扣默认链表节点是上面的定义，虚拟头结点要自己设置，最后再把虚拟头结点赋给题目给的原头结点即可
```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode* cur = dummyHead;
        while (cur->next != NULL) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```
## 栈和队列
本质上是容器适配器（vector、deque双向队列、list才是容器）这些容器又包装了最底层的array数组，有函数、无上限、自动回收    
stack和queue的底层容器都是deque，deque
std::deque使用了一种分段存储（chunked storage）结构。数据被分成多个固定大小的块（block），这些块的指针存储在一个中央数组中
## 哈希表
### 数组哈希（元素有限个数）、set、map
快慢指针可以用来确定是否成环的数学证明：假设链表长度为L，环的长度为C。当快指针和慢指针第一次相遇时，快指针走过的距离是L+nC（其中n是快指针走过环的圈数），慢指针走过的距离是L。由于快指针的速度是慢指针的两倍，所以有2L=L+nC，即L=nC。这意味着链表的长度是环长度的整数倍。  
哈希表的本质就是一个数组，快速判断一个元素是否在集合里，一个元素是否出现过，是否重复出现。
本质就是flag数组同时带有计数作用  
例如查找一个学生名字是否在学校里，暴力O(n)，哈希O(1)  
常见的三种哈希结构  
* 数组 有限
* map 无限而且需要其他信息
* set 无限

lc1002 读题暴力是四次方复杂度，想到用哈希。要找多个哈希表的共性，想到最大最小值。  





   



## 二叉树

c++函数传参的时候只有再上一层才有操纵指针指向的东西的权力。注意力扣环境下二叉树根节点深度为1。二叉树通常链表存储，但数组存储用于层序遍历也可以。    
**操作过程中边界条件时刻想着！！！判断空**

```c++
// 二叉树
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```


###  **二叉树的遍历方式**

- 二叉树问题其实算是某种弱化版的回溯。核心其实还是在于单层递归的逻辑，边界条件是单层递归非正常情况的处理（一般用于排除边界或汇总结果），函数内逻辑则是正常情况的处理。关于递归参数使用①全局变量还是传参的问题（传参②值传递还是③引用传递），值传递会产生额外的copy开销，但可以在不影响本层的情况下不手动回溯/直接使用临时参数（ dfs(root.left, path + root.val + "->", res);）。引用传递和使用全局变量每次手动操作都要手动回溯撤销。

* 二叉树递归遍历 三要素①参数和返回值②终止条件③单层递归逻辑
* 二叉树非递归（迭代遍历） 为什么能非递归遍历，其实就是用栈模拟递归的过程。这里还涉及访问顺序和处理操作顺序不一致的问题（先序是中左右入栈，但中序是左中右，而处理顺序一定是中优先，固不一致）**本质是只有根节点具有访问到子节点的能力/指针，才能像先序那样访问顺序和处理顺序一致**。所以中序的话就要靠指针去刻意指路再靠栈去访问。
* 我们就会递归遍历和非递归遍历足矣，统一遍历方法了解即可。  
* 层序遍历就一句话，无边界while里套有边界for，每次遍历一层

涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。

求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。

求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

**前中后序遍历虽然都是dfs，但是存在遍历顺序的问题，例如找从根到叶子的所有路径就必须使用前序遍历。**


求树的高度用后序遍历，求树的深度用前序遍历，数值如果一样无所谓（例如求最大高度深度的时候）但像判断是否是平衡二叉树的时候就必须用后序遍历来一层层判断。  



---




### 1.**二叉树相关性质**

* **节点与层次关系**
  - **层次**：根节点为第 1 层，其子节点为第 2 层，依次类推。
  - **第 \( k \) 层的最大节点数**：  
    \[
    2^{k-1}
    \]
  - **深度为 \( h \) 的二叉树的最大节点数**：  
    \[
    2^h - 1
    \]

* **完全二叉树的性质**
  - **节点编号**：对于完全二叉树中的节点（从 1 开始编号）：
    - 父节点编号为 \( i \)，则其左子节点编号为 \( 2i \)，右子节点编号为 \( 2i + 1 \)。
    - 子节点编号为 \( i \)，其父节点编号为 \( \lfloor i/2 \rfloor \)。
  - **高度 \( h \) 与节点数 \( n \) 的关系**：
    \[
    h = \lceil \log_2(n+1) \rceil
    \]

* **满二叉树的性质**
  - **节点总数**：若深度为 \( h \)，节点总数为：
    \[
    2^h - 1
    \]
  - **叶子节点数**：叶子节点数等于非叶子节点数加 1。


* **一般二叉树的性质**
  - **节点关系**：
    - \( n_0 \): 叶子节点数
    - \( n_2 \): 度为 2 的节点数  
    则有：
    \[
    n_0 = n_2 + 1
    \]
  - **总节点数 \( n \)**：
    \[
    n = n_0 + n_1 + n_2
    \]
    - \( n_0 \): 度为 0 的节点（叶子节点）
    - \( n_1 \): 度为 1 的节点
    - \( n_2 \): 度为 2 的节点

---



### 3. **特殊二叉树**
- **满二叉树**：所有非叶子节点的度均为 2，所有叶子节点在同一层。
- **完全二叉树**：深度为 \( h \) 的二叉树，除第 \( h \) 层外，其余各层节点数均达到最大，第 \( h \) 层从左到右连续存在节点。
- **二叉搜索树（BST）**：有序树。左子树所有节点值小于根节点值，右子树所有节点值大于根节点值。

---

### 4. **应用中的二叉树**
- **堆**：满足堆性质的完全二叉树（如最大堆和最小堆）。
- **哈夫曼树**：一种带权路径长度最短的二叉树。
- **AVL 树**：一种高度平衡的二叉搜索树。它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

---

## 回溯
**回溯模板，一个for处理同层，递归解决深度，终止条件收集ans，一般还要传for循环的startindex用来剪枝和确定深度层数**  
**其实就是迭代（或者多个if）+递归，深入版的遍历。**  


为什么暴力搜索要用回溯不直接for循环？因为比如组合数例子，如果三个位置就要用三层for循环，m层连代码都写不出来  
**如果解决一个问题有多个步骤，每一个步骤有多种方法，题目又要我们找出所有的方法（或者在所有方法里做优化），可以使用回溯算法；**

代码随想录的图适合分析逻辑不适合分析时间复杂度

其实回溯的一大考察点是剪枝，因为时间复杂度都一样sai。  
* for循环的范围，可以列个不等式
* 权的大小是否已经满足条件，根据题目而定

## 分治、dp、贪心、回溯、dfs、树的遍历比较
注意递归一定能写成迭代，递归不是手段，只是有时候契合算法思想。  
### **总结**：

- 分治就是**后序遍历**的思想，可以通过**动态规划**优化。
- **动态规划**通过记录子问题的解来优化分治法，并且**贪心**是动态规划的特例。
- 解决最优化问题往往要遍历解空间。**回溯法就是带剪枝的dfs**遍历解空间，可以视为等同。树的遍历有点区别因为节点带值而且并非多叉，**相对独立**一点吧，但树的前中后遍历其实都是dfs，层序遍历是bfs，这里理解下
- 动态规划其实就是从最优子问题出发，我当前状态要达到最优肯定是从**之前一定最优的最优状态**经过**操作**到达的当前状态。状态可以单加一维dp数组表示也可以用if、max、min表示，仅达到当前某单一状态需要前序多个状态作为来源的时候考虑加维度，或者需要只访问前一个状态的时候也可以加维度（打家劫舍）。**能做的操作有时候也会被前序状态限制（冷冻期），这句话用一系列股票问题好好体会**

**分治（后序思想）** 分治思想（分，计算，合并）的思想十分契合递归，而回溯、dp、贪心其实都是递归思想（dp的写法可以用迭代写，但思想还是递归）因此分治不是一个单独的题的类型。归并排序是最优子结构，组合数不是       
**dp**是特殊的分治带最优子结构（和重叠子问题）的分治 也是先分 再自底向上计算合并 相当于把重叠的存起来。下一步最优解一定和前一步有关系。动态规划两层for或者递归实现，完美形式是 带备忘的递归改写的嵌套循环。  
**贪心**是只走一条路走完就是最优解（得到证明的前提下）局部最优解就是全局最优解的dp优化。下一步最优解不一定和之前有关系（可以有关系，像哈夫曼就和前面有关系，安排活动就和之前状态没关系（可选择子集仍然是那些活动没有新活动））。实际上也可以看成自底向上哈。（也有说法说贪心算法通常都是这种自顶向下的设计：作出一个选择，然后求解剩下的那个子问题，这样其实也是自底向上只不过是先解决一部分。见仁见智）**在决策树层面贪心和回溯是自顶向下做选择，但由小问题最终构成大问题层面都是自底向上！**     
**回溯** 一开始就自底向上做选择直到达到边界 是暴力搜复杂度是指数级起步（跟树的节点数有关）可以处理子问题对前面的结果有依赖的问题（组合问题，这里的子问题是做出不同选择产生的新子问题，不满足dp），也基本可以处理所有dp问题（例如斐波那契，没得选择但也可以叫回溯）但是时间会爆炸不能用，要用dp优化。  






回溯法的时间复杂度分析，以组合问题为例。  
这里实际上是天然剪枝过的图，不然取2之后还要在134里取，只不过忽略掉了。考虑时间复杂度时原本是做2^n次选择（也可以用取或不取一个数来理解最后结果集都一样），再加上每个选择要push_back一下是on（组合不是，子集问题是，组合问题就先这样写了最高也不会超过子集问题，因为组合就是子集问题的一种），所以才有最后的时间复杂度。  
![](https://cdn.jsdelivr.net/gh/EuphratesG/myPic@main/202411271528938.png)
```c++
class Solution {
private:
    vector<vector<int>> result; // 存放符合条件结果的集合
    vector<int> path; // 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n; i++) {
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1); // 递归
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        result.clear(); // 可以不写
        path.clear();   // 可以不写
        backtracking(n, k, 1);
        return result;
    }
};
```

跳楼梯问题的回溯解法，会超时，所以用dp
```c++
class Solution {
public:
    int climbStairs(int n) {
        int result = 0;
        backtracking(0, n, result);
        return result;
    }

    // backtracking 函数：递归地探索所有可能的跳法
    void backtracking(int current, int n, int& result) {
        // 终止条件：如果当前已经到达楼顶，增加一种有效的路径
        if (current == n) {
            result++; // 记录到达楼顶的一个方案
            return;
        }

        // 递归选择：可以选择爬1个台阶或爬2个台阶，这里选择前后没有依赖就不用for循环和手动回溯了
        if (current + 1 <= n) {
            backtracking(current + 1, n, result);  // 爬1个台阶
        }
        if (current + 2 <= n) {
            backtracking(current + 2, n, result);  // 爬2个台阶
        }
    }
};
```



## 动态规划 dp方程考虑的是平凡i而不是最后的i
dp数组下标及含义、递推公式、数组初始化、遍历顺序/方向、打印dp数组  
01背包和爬楼梯的区别在于加了背包容量的限制，这样就有两个维度要选择/遍历：物品、背包容量，爬楼梯只有一个维度：当前爬的阶数。当然01背包还可以不单独加一个dp数组维度，而是用dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);表示  
滚动数组相当于还是两个for反复更新外层循环次dp数组，一开始全初始化为0，因此背包顺序必须倒序（原因简而言之就是当前物品遍历需要用到上一次物品遍历的结果，如果背包顺序遍历的话就会用到这一次物品遍历的结果，产生错误的累计（j - weight[i]的原因）），且遍历顺序必须是先物品后背包。**把物品一个个往不同大小的背包里放，外层for的每个循环都是一个物品**，**01背包从后往前遍历，完全背包从前往后，而且物品重量超过背包容量的要予以跳过**。    


### 基础问题（含打家劫舍）
lc213 成环的打家劫舍，分类讨论的思想不错  

### 背包问题
排列组合数问题，就用dp[3]来分析  
lc96 找子状态一个个抽，体现动态规划是对暴力回溯的优化，这个找来源的思想还不错，体现和回溯的关系  
#### 本质分类
- 能否装满背包？/装不满最多装多少、装满背包最大价值、装满背包最小物品数 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
- 装满背包几种方法 494 518 377 70  dp[j] += dp[j - nums[i]]

#### 遍历顺序 我们先全用一维dp数组
一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历

```c++

        // 开始 01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) { 
// 每一个元素一定是不可重复放入，所以从大到小遍历。
//注意j >= nums[i]意思是对对于比当前遍历的物品的重量还小的背包容量肯定放不下
//也就不需要更新dp数组了
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
```
说完01背包，再看看完全背包。

先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

如果求组合数就是外层for循环遍历物品，内层for遍历背包。

如果求排列数就是外层for遍历背包，内层for循环遍历物品。
```c++
//先物品是组合数
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
//1和2分别打头是两种不同的，因此先背包是排列数
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

### 股票问题
初始化时必须要编个理由能说的过去，就像限制买两次的股票问题。其实就是为了让状态转移能进行下去，给不合理的初始化找个合理的名头。这里的名头是dp[1][3]要比price[0]和price[1]，因此要找最大值。  

### 序列问题
- 单个数组上的问题
- 两个数组上的问题ij
- 单个数组回文-> <-向里缩


kmp ababaa  b和a比较不等，那么回到b和a比较，你看是不是还是相同前缀的下一个字母，所以要回退 就想成很巧妙的只差了一个i的取值好了01